<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Mini Juego 3D de Aviones - Móvil</title>
<style>
  html,body { margin:0; padding:0; height:100%; overflow:hidden; -webkit-user-select:none; -webkit-touch-callout:none; }
  canvas { display:block; width:100%; height:100% }

  /* HUD */
  .hud {
    position: absolute;
    left: 0; top: 0;
    width: 100%;
    pointer-events: none;
    display: flex;
    justify-content: space-between;
    padding: 8px;
    box-sizing: border-box;
    color: white;
    font-family: system-ui, sans-serif;
    text-shadow: 0 1px 2px rgba(0,0,0,0.7);
  }
  .score { pointer-events: none; font-size: 16px; }

  /* Botones táctiles */
  .controls {
    position: absolute;
    bottom: 12px;
    left: 12px;
    pointer-events: none; /* children override */
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .btn {
    width: 64px;
    height: 64px;
    border-radius: 12px;
    background: rgba(0,0,0,0.45);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 18px;
    user-select: none;
    -webkit-user-select: none;
    pointer-events: auto;
    touch-action: none;
  }
  .btn:active { transform: scale(0.97); background: rgba(0,0,0,0.6); }
  .right-controls {
    position: absolute;
    right: 12px;
    bottom: 12px;
    display: flex;
    gap: 8px;
    pointer-events: none;
  }
  .center-joystick {
    display:flex;
    flex-direction: column;
    gap: 8px;
    align-items:center;
  }
  .row {
    display:flex;
    gap:8px;
  }
  .top-bar { pointer-events:none; }

  /* Texto pequeño en botones en móviles */
  .btn small { font-size: 12px; display:block; line-height:1; opacity:0.9; }

  /* Para evitar selección/scroll cuando tocamos el canvas */
  body, .btn { -webkit-tap-highlight-color: rgba(0,0,0,0); }
</style>
</head>
<body>
<div id="container"></div>

<div class="hud">
  <div class="score">Puntos: <span id="score">0</span></div>
  <div class="score">Vida: <span id="health">3</span></div>
</div>

<!-- Controles táctiles -->
<div class="controls" aria-hidden="true">
  <div class="center-joystick">
    <div class="row">
      <div class="btn" id="btn-up">↑</div>
    </div>
    <div class="row">
      <div class="btn" id="btn-left">←</div>
      <div class="btn" id="btn-down">↓</div>
      <div class="btn" id="btn-right">→</div>
    </div>
  </div>
</div>

<div class="right-controls">
  <div class="btn" id="btn-fire">FIRE</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
/*
  Mini juego 3D de aviones para móvil con botones táctiles.
  - Usa Three.js (CDN)
  - Controles: arriba/abajo/izq/der + FIRE
  - Cámara sigue al avión
  - Enemigos simples (cubes) y balas (esferas)
*/

let scene, camera, renderer;
let plane, planeGroup;
let bullets = [];
let enemies = [];
let score = 0;
let health = 3;
let lastSpawn = 0;
let spawnInterval = 1500; // ms
let lastFire = 0;
let fireCooldown = 300; // ms
let width = window.innerWidth, height = window.innerHeight;

// Controles estado
const controls = {
  left: false,
  right: false,
  up: false,
  down: false,
  fire: false
};

init();
animate();

function init() {
  // Escena
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb); // cielo

  // Cámara
  camera = new THREE.PerspectiveCamera(60, width/height, 0.1, 2000);
  camera.position.set(0, 4, 12);

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setSize(width, height);
  renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
  document.getElementById('container').appendChild(renderer.domElement);

  // Luz
  const hemi = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.9);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(5,10,7);
  scene.add(dir);

  // Suelo (simple)
  const groundGeo = new THREE.PlaneGeometry(2000,2000,1,1);
  const groundMat = new THREE.MeshPhongMaterial({ color: 0x3c9b35, depthWrite: false });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -20;
  scene.add(ground);

  // Avión (geom simple)
  planeGroup = new THREE.Group();
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(1.2, 0.6, 3),
    new THREE.MeshPhongMaterial({ color: 0xff3333 })
  );
  body.position.z = 0;
  planeGroup.add(body);

  const wingMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
  const wing = new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 1.2), wingMat);
  wing.position.set(0, -0.1, 0);
  planeGroup.add(wing);

  const tail = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.1), wingMat);
  tail.position.set(0, 0.8, -1.1);
  planeGroup.add(tail);

  planeGroup.position.set(0, 2, 0);
  scene.add(planeGroup);
  plane = planeGroup;

  // Event listeners
  window.addEventListener('resize', onWindowResize, false);

  // Touch buttons
  bindButton('btn-left', () => controls.left = true, () => controls.left = false);
  bindButton('btn-right', () => controls.right = true, () => controls.right = false);
  bindButton('btn-up', () => controls.up = true, () => controls.up = false);
  bindButton('btn-down', () => controls.down = true, () => controls.down = false);
  bindButton('btn-fire', () => controls.fire = true, () => controls.fire = false);

  // Prevent page scroll on touch inside body
  document.body.addEventListener('touchmove', function(e){ e.preventDefault(); }, { passive:false });

  // Start with a few enemies
  for (let i=0;i<4;i++) spawnEnemy(true);
}

function bindButton(id, onStart, onEnd){
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('touchstart', (e)=>{ e.preventDefault(); onStart(); }, {passive:false});
  el.addEventListener('mousedown', (e)=>{ e.preventDefault(); onStart(); });
  el.addEventListener('touchend', (e)=>{ e.preventDefault(); onEnd(); }, {passive:false});
  el.addEventListener('mouseup', (e)=>{ e.preventDefault(); onEnd(); });
  el.addEventListener('touchcancel', (e)=>{ e.preventDefault(); onEnd(); }, {passive:false});
}

function onWindowResize(){
  width = window.innerWidth;
  height = window.innerHeight;
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
}

function animate(time){
  requestAnimationFrame(animate);
  const dt = Math.min(50, time ? (time - (animate.lastTime || time)) : 16) / 1000;
  animate.lastTime = time;

  update(dt, time);
  renderer.render(scene, camera);
}

function update(dt, time){
  handleControls(dt);
  updateBullets(dt);
  updateEnemies(dt);
  cameraFollow();
  // spawn enemies periodically
  if(!time) time = performance.now();
  if(time - lastSpawn > spawnInterval){
    spawnEnemy();
    lastSpawn = time;
  }
}

function handleControls(dt){
  const speed = 10; // lateral speed
  const tiltAmount = 0.02;
  // Move plane based on controls
  if(controls.left) plane.position.x -= speed * dt;
  if(controls.right) plane.position.x += speed * dt;
  if(controls.up) plane.position.y += speed * dt;
  if(controls.down) plane.position.y -= speed * dt;
  // Clamp vertical/horizontal ranges
  plane.position.y = Math.max(0.8, Math.min(12, plane.position.y));
  plane.position.x = Math.max(-20, Math.min(20, plane.position.x));

  // Slight tilting visual
  plane.rotation.z = - (plane.position.x / 30) * 0.6; // tilt with x pos

  // Auto-forward movement
  plane.position.z -= 20 * dt; // always goes "forward" negative z
  // Fire handling
  const now = performance.now();
  if(controls.fire && now - lastFire > fireCooldown){
    shoot();
    lastFire = now;
  }
}

function shoot(){
  const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.12,8,8), new THREE.MeshBasicMaterial({color:0xffff00}));
  // spawn at nose of plane
  const worldPos = new THREE.Vector3();
  plane.getWorldPosition(worldPos);
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(plane.quaternion);
  sphere.position.copy(worldPos).add(forward.clone().multiplyScalar(1.8)).add(new THREE.Vector3(0,0,-0.1));
  sphere.userData = { vel: forward.clone().multiplyScalar(60), life: 2.5 }; // seconds
  bullets.push(sphere);
  scene.add(sphere);
}

function updateBullets(dt){
  for (let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.position.addScaledVector(b.userData.vel, dt);
    b.userData.life -= dt;
    if(b.userData.life <= 0){
      scene.remove(b);
      bullets.splice(i,1);
      continue;
    }
    // Collision with enemies
    for (let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      const dist = b.position.distanceTo(e.position);
      if(dist < (e.userData.size + 0.12)*0.9){
        // Hit
        spawnExplosion(e.position);
        scene.remove(e);
        enemies.splice(j,1);
        scene.remove(b);
        bullets.splice(i,1);
        score += 10;
        updateHUD();
        break;
      }
    }
  }
}

function spawnEnemy(initial=false){
  const size = 0.8 + Math.random()*1.6;
  const geo = new THREE.BoxGeometry(size, size, size);
  const mat = new THREE.MeshPhongMaterial({ color: new THREE.Color().setHSL(Math.random()*0.6, 0.8, 0.45) });
  const mesh = new THREE.Mesh(geo, mat);
  // Spawn ahead of the plane (more negative z)
  let z = plane.position.z - (50 + Math.random()*80);
  // Spread on x axis
  let x = (Math.random()*2-1) * 25;
  let y = 1 + Math.random()*8;
  mesh.position.set(x, y, z);
  mesh.userData = { size: size*0.5 };
  enemies.push(mesh);
  scene.add(mesh);

  // if initial, make spawn interval quicker to populate
  if(initial) lastSpawn = performance.now() - (spawnInterval*0.2);
}

function updateEnemies(dt){
  for (let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    // simple movement: move towards plane slowly (z increases towards plane)
    // But enemies should mostly move forward toward player (increase z)
    e.position.z += 8 * dt;
    // slight sway
    e.position.x += Math.sin((performance.now()/300)+i) * 0.5 * dt;
    // If reached close to plane (collision)
    const dist = e.position.distanceTo(plane.position);
    if(dist < (e.userData.size + 0.8)){
      // collision - lose life
      spawnExplosion(plane.position);
      scene.remove(e);
      enemies.splice(i,1);
      health -= 1;
      updateHUD();
      if(health <= 0) {
        gameOver();
      }
      continue;
    }
    // Remove enemies that passed behind the plane
    if(e.position.z > plane.position.z + 10){
      scene.remove(e);
      enemies.splice(i,1);
      continue;
    }
  }
}

function spawnExplosion(pos){
  // small visual: a quickly expanding sphere (no particles for simplicity)
  const geo = new THREE.SphereGeometry(0.2,8,8);
  const mat = new THREE.MeshBasicMaterial({ color: 0xffcc33, transparent:true });
  const sp = new THREE.Mesh(geo, mat);
  sp.position.copy(pos);
  scene.add(sp);
  // animate and remove
  const start = performance.now();
  const dur = 350;
  const anim = function(t){
    const tt = (t - start) / dur;
    if(tt >= 1){
      scene.remove(sp);
      return;
    }
    sp.scale.setScalar(1 + tt*6);
    sp.material.opacity = 1 - tt;
    requestAnimationFrame(anim);
  };
  requestAnimationFrame(anim);
}

function cameraFollow(){
  // Smooth camera follow behind the plane
  const desiredPos = new THREE.Vector3(plane.position.x, plane.position.y + 3.5, plane.position.z + 12);
  camera.position.lerp(desiredPos, 0.08);
  const lookAt = new THREE.Vector3(plane.position.x, plane.position.y, plane.position.z - 10);
  camera.lookAt(lookAt);
}

function updateHUD(){
  document.getElementById('score').textContent = score;
  document.getElementById('health').textContent = Math.max(0, health);
}

function gameOver(){
  // Freeze game and show simple alert
  controls.left = controls.right = controls.up = controls.down = controls.fire = false;
  // Remove remaining enemies and bullets
  bullets.forEach(b=>scene.remove(b));
  enemies.forEach(e=>scene.remove(e));
  bullets = [];
  enemies = [];
  setTimeout(()=> {
    alert('Juego terminado. Puntuación: ' + score + '\nRefresca la página para jugar otra vez.');
  }, 200);
}

// Simple instructions: tap buttons to control.
// Prevent accidental long-press context menu:
window.addEventListener('contextmenu', function(e){ e.preventDefault(); }, false);
</script>
</body>
</html>