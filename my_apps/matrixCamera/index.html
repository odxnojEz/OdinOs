<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matrix Camera Effect — Controles</title>

  <!-- PWA / WebApp metas to allow "standalone" (fullscreen) when el usuario instala la app -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <!-- black-translucent mantiene la zona superior del sistema (notch) con translucidez en iOS -->
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#000000">

  <!-- Manifest inline via data URL (para poder usar un único archivo HTML) -->
  <link id="manifestLink" rel="manifest" href='data:application/json,{"name":"Matrix Camera — Controles","short_name":"MatrixCam","start_url":".","display":"standalone","orientation":"any","background_color":"#000000","theme_color":"#000000","icons":[{"src":"data:image/svg+xml;utf8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 256 256%27%3E%3Crect width=%27100%25%27 height=%27100%25%27 fill=%27%23000%27/%3E%3Ctext x=%2750%25%27 y=%2754%25%27 font-size=%27140%27 fill=%27%2300ff66%27 font-family=%27monospace%27 dominant-baseline=%27middle%27 text-anchor=%27middle%27%3EM%3C/text%3E%3C/svg%3E\",\"sizes\":\"192x192\",\"type\":\"image/svg+xml\"}]}'>

  <!-- Apple touch icon (inline SVG as data URL) -->
  <link rel="apple-touch-icon" href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><rect width="100%" height="100%" fill="#000"/><text x="50%" y="54%" font-size="140" fill="#00ff66" font-family="monospace" dominant-baseline="middle" text-anchor="middle">M</text></svg>'>

  <style>
    /* Basic page reset */
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      color: #0f0;
      font-family: monospace;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      /* Respect iOS safe area (notch) when running standalone */
      padding-top: env(safe-area-inset-top);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      padding-bottom: env(safe-area-inset-bottom);
    }

    /* Fullscreen canvas */
    #app {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #000;
    }

    /* UI controls panel */
    .controls {
      position: absolute;
      /* ensure controls don't clash with the notch / status bar on standalone */
      top: calc(12px + env(safe-area-inset-top));
      left: calc(12px + env(safe-area-inset-left));
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 50;
      min-width: 220px;
      background: rgba(0,10,0,0.55);
      border: 1px solid rgba(0,255,0,0.18);
      padding: 10px;
      border-radius: 8px;
      backdrop-filter: blur(6px);
    }

    .row {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #c8ffc8;
      font-size: 13px;
    }

    .label {
      min-width: 80px;
      color: #9fff9f;
    }

    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 10px;
      background: transparent;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      background: rgba(0,255,0,0.12);
      border-radius: 6px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 16px;
      width: 16px;
      border-radius: 50%;
      background: rgba(0,255,0,0.95);
      margin-top: -5px;
      box-shadow: 0 0 8px rgba(0,255,0,0.35);
    }

    .btns {
      display: flex;
      gap: 8px;
      margin-top: 4px;
      align-items: center;
    }

    .btn {
      background: rgba(0,0,0,0.6);
      color: #0f0;
      border: 1px solid rgba(0,255,0,0.15);
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 6px;
      font-family: monospace;
      font-size: 14px;
      backdrop-filter: blur(4px);
    }

    .btn:disabled { opacity: 0.45; cursor: not-allowed; }
    .btn:active { transform: translateY(1px); }

    /* Hidden video used as source for the canvas */
    video#videoSource {
      display: none;
    }

    /* Small info line */
    .info {
      position: absolute;
      bottom: calc(10px + env(safe-area-inset-bottom));
      left: calc(10px + env(safe-area-inset-left));
      color: rgba(0,255,0,0.8);
      font-size: 12px;
      z-index: 20;
      font-family: monospace;
    }

    /* Small hint style for install button availability */
    .installHint {
      font-size: 11px;
      color: rgba(160,255,160,0.9);
      margin-left: 6px;
    }
  </style>
</head>
<body>
  <div id="app" aria-live="polite">
    <canvas id="matrixCanvas"></canvas>

    <!-- Hidden video element capturing camera frames -->
    <video id="videoSource" autoplay muted playsinline></video>

    <!-- Controls -->
    <div class="controls" role="region" aria-label="Controles de Matrix">
      <div class="row">
        <div class="label">Transparencia</div>
        <input id="opacityRange" type="range" min="0.2" max="1.6" step="0.05" value="1.00" aria-label="Transparencia de letras">
        <div id="opacityVal">1.00</div>
      </div>

      <div class="row">
        <div class="label">Cantidad</div>
        <!-- Min 0 (ninguna), Max = 80 (muy denso) -->
        <input id="densityRange" type="range" min="0" max="80" step="0.1" value="1.6" aria-label="Cantidad de letras">
        <div id="densityVal">1.60</div>
      </div>

      <div class="row">
        <div class="label">Velocidad</div>
        <input id="speedRange" type="range" min="0.3" max="3.0" step="0.05" value="1.4" aria-label="Velocidad de caída">
        <div id="speedVal">1.40</div>
      </div>

      <div class="btns">
        <button id="startBtn" class="btn">Iniciar Cámara</button>
        <button id="stopBtn" class="btn" disabled>Parar</button>
        <!-- Install button: mostrará el prompt de instalación cuando el navegador lo permita -->
        <button id="installBtn" class="btn" style="display:none;">Instalar</button>
        <div id="installHint" class="installHint" aria-hidden="true" style="display:none;">(Añadir a la pantalla inicio para abrir en modo app)</div>
      </div>
    </div>

    <div class="info">Permite la cámara, ajusta transparencia, cantidad y velocidad.</div>
  </div>

  <script>
    // Matrix Camera Effect SPA with controls (Spanish labels)
    // Mejora: al aumentar "Cantidad" se nota mucho más — columnas se distribuyen por todo el ancho.

    // Grab DOM elements
    const canvas = document.getElementById('matrixCanvas');
    const ctx = canvas.getContext('2d');
    const video = document.getElementById('videoSource');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');

    const opacityRange = document.getElementById('opacityRange');
    const densityRange = document.getElementById('densityRange');
    const speedRange = document.getElementById('speedRange');
    const opacityVal = document.getElementById('opacityVal');
    const densityVal = document.getElementById('densityVal');
    const speedVal = document.getElementById('speedVal');

    const installBtn = document.getElementById('installBtn');
    const installHint = document.getElementById('installHint');

    // Offscreen canvas to sample video pixels at canvas resolution
    let offscreen = null;
    let offCtx = null;

    // Animation and stream state
    let stream = null;
    let animationId = null;

    // Device pixel ratio for crisp rendering
    const DPR = Math.max(1, window.devicePixelRatio || 1);

    // Characters to use for the Matrix effect (mix of katakana-ish and ascii)
    const chars = 'アァヅシソンヒミリレロ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz@#$%&*+-=[]{}<>';

    // Settings - tweak for performance / look
    let fontSize = 18;                // base font size (CSS pixels)
    let columns = [];                 // array of column objects
    let columnCount = 0;
    let fadeAlpha = 0.06;             // trail fade (lower = longer trails)
    let speedMin = 6;                 // base min drop speed (pixels per frame)
    let speedMax = 16;                // base max drop speed
    // Controlled values (bound to UI):
    let density = parseFloat(densityRange.value);       // columns density multiplier
    let speedMultiplier = parseFloat(speedRange.value); // speed multiplier (UI)
    let charOpacity = parseFloat(opacityRange.value);   // overall letters opacity multiplier (UI)

    // Initialize UI display values
    opacityVal.textContent = charOpacity.toFixed(2);
    densityVal.textContent = density.toFixed(2);
    speedVal.textContent = speedMultiplier.toFixed(2);

    // Install prompt handling (beforeinstallprompt)
    let deferredPrompt = null;
    window.addEventListener('beforeinstallprompt', (e) => {
      // Prevent mini-infobar from appearing on mobile
      e.preventDefault();
      deferredPrompt = e;
      installBtn.style.display = 'inline-block';
      installHint.style.display = 'inline-block';
    });

    installBtn.addEventListener('click', async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      const choice = await deferredPrompt.userChoice;
      // Hide install UI after prompt
      installBtn.style.display = 'none';
      installHint.style.display = 'none';
      deferredPrompt = null;
    });

    // Initialize canvas size and columns based on current window size
    function resize() {
      const width = Math.floor(window.innerWidth);
      const height = Math.floor(window.innerHeight);

      canvas.width = Math.floor(width * DPR);
      canvas.height = Math.floor(height * DPR);
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';

      // create or resize offscreen canvas to match displayed canvas
      if (!offscreen) {
        offscreen = document.createElement('canvas');
        offCtx = offscreen.getContext('2d');
      }
      offscreen.width = canvas.width;
      offscreen.height = canvas.height;

      // Choose font size in device pixels
      const effectiveFont = Math.max(8, Math.floor(fontSize * DPR));
      ctx.textBaseline = 'top';
      ctx.font = `${effectiveFont}px monospace`;
      // Make the rendering more verdant: stronger green shadow
      ctx.fillStyle = '#0f0';
      ctx.shadowColor = 'rgba(0,255,80,0.26)';
      ctx.shadowBlur = 6;

      // Calculate approximate base column count based on font width
      const approxColWidth = Math.max(6, Math.floor(effectiveFont * 0.55));
      const baseColumns = Math.max(1, Math.floor(canvas.width / approxColWidth));

      // New columnCount: baseColumns scaled by density. If density==0, zero columns.
      columnCount = (density <= 0) ? 0 : Math.max(1, Math.floor(baseColumns * density));

      // Distribute columns evenly across the canvas width so increasing density is visible
      if (columnCount > 0) {
        const spacing = canvas.width / columnCount; // spacing in device pixels
        columns = new Array(columnCount).fill(0).map((_, i) => {
          return {
            x: Math.floor(i * spacing), // evenly distributed x
            y: Math.floor(Math.random() * canvas.height) - Math.floor(Math.random() * canvas.height),
            baseSpeed: Math.floor(Math.random() * (speedMax - speedMin + 1)) + speedMin, // base speed
            charTimer: 0,
            charInterval: Math.floor(Math.random() * 6) + 1,
            spacing,
            approxColWidth
          };
        });
      } else {
        columns = [];
      }
    }

    // Main draw loop
    function draw() {
      // Draw video frame to offscreen if available
      if (video.readyState >= 2) {
        try {
          offCtx.drawImage(video, 0, 0, offscreen.width, offscreen.height);
        } catch (err) {
          // ignore draw errors
        }
      } else {
        // If no video, clear offscreen
        offCtx.fillStyle = 'black';
        offCtx.fillRect(0, 0, offscreen.width, offscreen.height);
      }

      // Get pixel data (may fail if blocked)
      let frameData;
      try {
        frameData = offCtx.getImageData(0, 0, offscreen.width, offscreen.height).data;
      } catch (e) {
        frameData = null;
      }

      // Draw the camera frame faintly onto the main canvas as a background so the camera is visible through/behind the letters
      ctx.globalCompositeOperation = 'source-over';
      // keep camera subtle so green letters pop; slightly reduced alpha
      ctx.globalAlpha = 0.18;
      try {
        ctx.drawImage(offscreen, 0, 0);
      } catch (e) {
        // ignore if draw fails
      }
      ctx.globalAlpha = 1;

      // Draw a translucent black rect to create fading trails (keep as source-over)
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Use normal composition for characters
      ctx.globalCompositeOperation = 'source-over';

      const effectiveFont = Math.max(8, Math.floor(fontSize * DPR));

      for (let i = 0; i < columns.length; i++) {
        const col = columns[i];

        // occasionally change char to add variety
        col.charTimer++;
        if (col.charTimer >= col.charInterval) {
          col.charTimer = 0;
          col.charInterval = Math.floor(Math.random() * 6) + 1;
        }

        // select a random character
        const ch = chars.charAt(Math.floor(Math.random() * chars.length));

        // sample color at the column's head position from the video frame
        // use spacing to decide sample x position
        const sampleX = Math.min(offscreen.width - 1, Math.max(0, Math.floor((col.x + (col.spacing || col.approxColWidth) / 2))));
        const sampleY = Math.min(offscreen.height - 1, Math.max(0, Math.floor(col.y)));

        // fallback color & alpha if no frame data
        let fill = 'rgba(0,255,80,0.95)'; // stronger pure green fallback for visibility
        if (frameData) {
          const idx = (sampleY * offscreen.width + sampleX) * 4;
          let r = frameData[idx];
          let g = frameData[idx + 1];
          let b = frameData[idx + 2];
          // bias towards green to make the overall look "más verdoso"
          r = Math.floor(r * 0.55);
          b = Math.floor(b * 0.55);
          g = Math.min(255, Math.floor(g * 1.6 + 25));
          // base alpha for characters — scale and clamp, then apply UI multiplier
          const alphaSample = frameData[idx + 3] / 255;
          const baseAlpha = Math.max(0.12, alphaSample * 0.9);
          const alpha = Math.min(1, baseAlpha * charOpacity);
          fill = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
        } else {
          // If no frame data, still respect charOpacity
          const alpha = Math.min(1, 0.95 * charOpacity);
          fill = `rgba(0,255,80,${alpha.toFixed(3)})`;
        }

        // draw the main colored character
        ctx.fillStyle = fill;
        ctx.font = `${effectiveFont}px monospace`;
        ctx.fillText(ch, col.x, col.y);

        // Draw a verdant head highlight (pale green) with lower opacity so camera remains visible
        const headAlpha = Math.min(0.5, 0.28 * charOpacity);
        ctx.fillStyle = `rgba(200,255,210,${headAlpha.toFixed(3)})`;
        ctx.fillText(ch, col.x, col.y - Math.floor(effectiveFont * 0.72));

        // advance the column downward using baseSpeed * speedMultiplier and a small jitter
        const travel = (col.baseSpeed * speedMultiplier) * (0.9 + Math.random() * 0.4);
        col.y += travel;

        // reset column when it's past bottom with some randomness
        if (col.y > canvas.height + Math.random() * canvas.height * 0.5) {
          col.y = -Math.random() * canvas.height * 0.5;
          // keep x aligned to distributed grid (recompute from index to avoid drifting)
          col.x = Math.floor(i * (col.spacing || col.approxColWidth));
          // re-randomize base speed (so speed slider will scale it next frames)
          col.baseSpeed = Math.floor(Math.random() * (speedMax - speedMin + 1)) + speedMin;
        }
      }

      // Loop
      animationId = requestAnimationFrame(draw);
    }

    // Start camera and animation
    async function start() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
      } catch (err) {
        alert('Acceso a la cámara denegado o no disponible: ' + (err && err.message ? err.message : err));
        return;
      }

      video.srcObject = stream;
      await video.play().catch(() => { /* ignore play errors */ });

      resize();

      startBtn.disabled = true;
      stopBtn.disabled = false;

      if (!animationId) {
        animationId = requestAnimationFrame(draw);
      }
    }

    // Stop camera and animation, free resources
    function stop() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }

      try { video.srcObject = null; } catch (e) {}

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      startBtn.disabled = false;
      stopBtn.disabled = true;
    }

    // UI handlers to update parameters live
    opacityRange.addEventListener('input', (e) => {
      charOpacity = parseFloat(e.target.value);
      opacityVal.textContent = charOpacity.toFixed(2);
    });

    densityRange.addEventListener('input', (e) => {
      density = parseFloat(e.target.value);
      densityVal.textContent = density.toFixed(2);
      // recreate columns to reflect density change (0 allowed)
      resize();
    });

    speedRange.addEventListener('input', (e) => {
      speedMultiplier = parseFloat(e.target.value);
      speedVal.textContent = speedMultiplier.toFixed(2);
      // speeds of existing columns will be applied automatically in draw (baseSpeed * speedMultiplier)
    });

    // Event listeners
    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);

    // Maintain responsiveness
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      // throttle a bit to avoid thrashing on continuous resize
      if (resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        resize();
        resizeTimer = null;
      }, 120);
    });

    // Initial setup (columns will be created with current density)
    resize();

    // Note: For the "standalone / fullscreen" behavior to take effect the user needs to:
    // - instalar la web como PWA (Add to Home screen / Add to apps) o abrirla desde la pantalla de inicio.
    // - en la mayoría de navegadores de escritorio o móviles, la web debe servirse por HTTPS.
    // We provide the "Instalar" button when the browser supports the beforeinstallprompt event.
  </script>
</body>
</html>