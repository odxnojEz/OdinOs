<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Bowling - Turn Based</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Crucial for mobile games */
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Scoreboard Top */
        #scoreboard {
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 3px solid #00ffcc;
            padding: 15px 10px;
            text-align: center;
            color: white;
            box-shadow: 0 4px 15px rgba(0, 255, 204, 0.3);
        }

        .score-text { font-size: 24px; font-weight: bold; }
        .p1 { color: #ff0055; }
        .p2 { color: #0088ff; }
        
        #turn-info {
            font-size: 18px;
            margin-top: 5px;
            color: #ffcc00;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Controls Bottom */
        #controls {
            background: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,0));
            padding: 20px 10px 40px 10px;
            pointer-events: auto; /* Enable clicks here */
        }

        /* Power Meter */
        #power-container {
            width: 80%;
            height: 20px;
            background: #222;
            border: 2px solid #fff;
            border-radius: 10px;
            margin: 0 auto 20px auto;
            position: relative;
            overflow: hidden;
        }
        
        #power-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.05s linear;
        }

        /* Buttons */
        .btn-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            padding: 0 10px;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #fff;
            color: #fff;
            font-size: 24px;
            border-radius: 15px;
            height: 70px;
            flex: 1;
            font-weight: bold;
            box-shadow: 0 5px 0 rgba(255,255,255,0.3);
        }

        .action-btn:active {
            transform: translateY(5px);
            box-shadow: none;
        }

        #btn-throw {
            flex: 2;
            background: #ffcc00;
            color: #000;
            border-color: #ffcc00;
            box-shadow: 0 5px 0 #b38f00;
        }
        
        #btn-throw:active {
            box-shadow: none;
        }

        #message-overlay {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 2px 2px 10px #000;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>

<div id="game-container">
    </div>

<div id="ui-layer">
    <div id="scoreboard">
        <div class="score-text">
            <span class="p1">P1: <span id="s1">0</span></span>
            &nbsp;&nbsp;|&nbsp;&nbsp;
            <span class="p2">P2: <span id="s2">0</span></span>
        </div>
        <div id="turn-info">Player 1 - Frame 1 (Throw 1)</div>
    </div>

    <div id="message-overlay">STRIKE!</div>

    <div id="controls">
        <div id="power-container">
            <div id="power-bar"></div>
        </div>
        <div class="btn-row">
            <button id="btn-left" class="action-btn">◀</button>
            <button id="btn-throw" class="action-btn">THROW</button>
            <button id="btn-right" class="action-btn">▶</button>
        </div>
    </div>
</div>

<script>
    // --- GLOBAL VARIABLES ---
    let scene, camera, renderer, world;
    let ballMesh, ballBody;
    let pins = []; // Store objects { mesh, body, originalPos }
    
    // Game State
    let gameState = 'aiming'; // aiming, rolling, resetting
    let playerTurn = 1; // 1 or 2
    let frame = 1;
    let throwNum = 1;
    let scores = { 1: 0, 2: 0 };
    let pinsDownThisFrame = 0;

    // Power Meter
    let power = 0;
    let powerDir = 1;
    const POWER_SPEED = 2.5;

    // UI Elements
    const uiPowerBar = document.getElementById('power-bar');
    const uiS1 = document.getElementById('s1');
    const uiS2 = document.getElementById('s2');
    const uiTurnInfo = document.getElementById('turn-info');
    const uiMessage = document.getElementById('message-overlay');

    // --- INITIALIZATION ---
    function init() {
        // 1. Setup Three.js (Visuals)
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x050505, 10, 40);

        // Portrait Camera
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 3, 6); // Behind and above the ball
        camera.lookAt(0, 0, -10);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 2. Setup Cannon.js (Physics)
        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0); // Earth gravity
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Physics Materials
        const laneMaterial = new CANNON.Material("laneMaterial");
        const ballMaterial = new CANNON.Material("ballMaterial");
        const pinMaterial = new CANNON.Material("pinMaterial");

        const ballLaneContact = new CANNON.ContactMaterial(laneMaterial, ballMaterial, { friction: 0.1, restitution: 0.1 });
        const ballPinContact = new CANNON.ContactMaterial(ballMaterial, pinMaterial, { friction: 0.5, restitution: 0.6 });
        const pinPinContact = new CANNON.ContactMaterial(pinMaterial, pinMaterial, { friction: 0.3, restitution: 0.3 });
        
        world.addContactMaterial(ballLaneContact);
        world.addContactMaterial(ballPinContact);
        world.addContactMaterial(pinPinContact);

        // 3. Build Environment
        createLane(laneMaterial);
        createPins(pinMaterial);
        createBall(ballMaterial);

        // 4. Setup Controls
        setupControls();

        // 5. Start Loop
        animate();
    }

    // --- ENVIRONMENT CREATION ---
    function createLane(material) {
        // Visual Lane
        const laneGeo = new THREE.BoxGeometry(3, 0.5, 24);
        const laneMat = new THREE.MeshStandardMaterial({ color: 0xcda46b, roughness: 0.2 });
        const laneMesh = new THREE.Mesh(laneGeo, laneMat);
        laneMesh.position.set(0, -0.25, -8);
        laneMesh.receiveShadow = true;
        scene.add(laneMesh);

        // Physics Lane
        const laneBody = new CANNON.Body({ mass: 0, material: material });
        laneBody.addShape(new CANNON.Box(new CANNON.Vec3(1.5, 0.25, 12)));
        laneBody.position.copy(laneMesh.position);
        world.addBody(laneBody);

        // Gutters (Visual only for simplicity, ball falls off physics lane)
        const gutterGeo = new THREE.BoxGeometry(0.8, 0.4, 24);
        const gutterMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        
        const gutterL = new THREE.Mesh(gutterGeo, gutterMat);
        gutterL.position.set(-1.9, -0.3, -8);
        scene.add(gutterL);
        
        const gutterR = new THREE.Mesh(gutterGeo, gutterMat);
        gutterR.position.set(1.9, -0.3, -8);
        scene.add(gutterR);
    }

    function createPins(material) {
        const pinRadius = 0.15;
        const pinHeight = 0.8;
        const pinMass = 1.2;

        const pinGeo = new THREE.CylinderGeometry(pinRadius, pinRadius*1.5, pinHeight, 16);
        const pinMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        
        // Triangle setup
        const rows = 4;
        let startZ = -16;
        let spacingX = 0.4;
        let spacingZ = 0.4;

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col <= row; col++) {
                const x = (col * spacingX) - ((row * spacingX) / 2);
                const z = startZ - (row * spacingZ);
                const y = pinHeight / 2;

                // Visual
                const mesh = new THREE.Mesh(pinGeo, pinMat);
                mesh.castShadow = true;
                scene.add(mesh);

                // Physics (Cylinder in Cannon needs rotation to stand up properly)
                const shape = new CANNON.Cylinder(pinRadius, pinRadius*1.5, pinHeight, 16);
                const body = new CANNON.Body({ mass: pinMass, material: material });
                body.addShape(shape);
                
                // Cannon cylinders point along Z axis by default, rotate to Y
                const quat = new CANNON.Quaternion();
                quat.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
                body.quaternion.copy(quat);

                body.position.set(x, y, z);
                world.addBody(body);

                pins.push({
                    mesh: mesh,
                    body: body,
                    originalPos: new CANNON.Vec3(x, y, z),
                    originalQuat: quat.clone(),
                    isDown: false
                });
            }
        }
    }

    function createBall(material) {
        const radius = 0.25;
        
        // Visual
        const geo = new THREE.SphereGeometry(radius, 32, 32);
        const mat = new THREE.MeshStandardMaterial({ color: 0xff0055, roughness: 0.1, metalness: 0.3 });
        ballMesh = new THREE.Mesh(geo, mat);
        ballMesh.castShadow = true;
        scene.add(ballMesh);

        // Physics
        ballBody = new CANNON.Body({ mass: 8, material: material });
        ballBody.addShape(new CANNON.Sphere(radius));
        ballBody.position.set(0, radius, 0); // Start position
        world.addBody(ballBody);
    }

    // --- CONTROLS & UI ---
    function setupControls() {
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnThrow = document.getElementById('btn-throw');

        const moveSpeed = 0.1;

        // Using touchstart/touchend for mobile responsiveness
        btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); if(gameState === 'aiming' && ballBody.position.x > -1.2) moveBall(-moveSpeed); });
        btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); if(gameState === 'aiming' && ballBody.position.x < 1.2) moveBall(moveSpeed); });
        
        btnThrow.addEventListener('touchstart', (e) => { 
            e.preventDefault(); 
            if(gameState === 'aiming') throwBall(); 
        });

        // Mouse fallback for testing on PC
        btnLeft.addEventListener('click', () => { if(gameState === 'aiming' && ballBody.position.x > -1.2) moveBall(-moveSpeed); });
        btnRight.addEventListener('click', () => { if(gameState === 'aiming' && ballBody.position.x < 1.2) moveBall(moveSpeed); });
        btnThrow.addEventListener('click', () => { if(gameState === 'aiming') throwBall(); });
    }

    function moveBall(amount) {
        ballBody.position.x += amount;
        ballBody.velocity.setZero();
        ballBody.angularVelocity.setZero();
    }

    // --- GAME LOGIC ---
    function throwBall() {
        gameState = 'rolling';
        
        // Apply force based on Power Meter (0 to 100)
        const throwForce = 300 + (power * 4); // Base force + power
        
        // Apply impulse forward (-Z)
        ballBody.applyLocalImpulse(new CANNON.Vec3(0, 0, -throwForce), new CANNON.Vec3(0, 0, 0));
        
        // Add a little random spin for realism
        ballBody.angularVelocity.set(0, (Math.random()-0.5)*10, 0);

        // Wait 4 seconds for physics to settle, then check results
        setTimeout(checkResults, 4000);
    }

    function checkResults() {
        gameState = 'resetting';
        let fallenThisThrow = 0;

        // Check each pin
        pins.forEach(pin => {
            if (!pin.isDown) {
                // Check if pin tipped over (rotation difference) or fell off edge
                const dot = pin.body.quaternion.vmult(new CANNON.Vec3(0,1,0)).y; 
                if (dot < 0.5 || pin.body.position.y < 0) {
                    pin.isDown = true;
                    fallenThisThrow++;
                    
                    // Move fallen pins out of the way for the next throw
                    pin.body.position.y = -5;
                }
            }
        });

        pinsDownThisFrame += fallenThisThrow;
        scores[playerTurn] += fallenThisThrow;
        updateScoreboard();

        if (pinsDownThisFrame === 10 && throwNum === 1) {
            showMessage("STRIKE!!");
            scores[playerTurn] += 2; // Bonus points
            setTimeout(nextTurn, 2000);
        } else if (pinsDownThisFrame === 10 && throwNum === 2) {
            showMessage("SPARE!");
            scores[playerTurn] += 1;
            setTimeout(nextTurn, 2000);
        } else if (throwNum === 1) {
            throwNum = 2;
            resetBallOnly();
        } else {
            setTimeout(nextTurn, 1000);
        }
    }

    function nextTurn() {
        if (playerTurn === 1) {
            playerTurn = 2;
            throwNum = 1;
        } else {
            playerTurn = 1;
            throwNum = 1;
            frame++;
        }
        
        pinsDownThisFrame = 0;
        updateScoreboard();
        resetFull();
    }

    function resetBallOnly() {
        ballBody.position.set(0, 0.25, 0);
        ballBody.velocity.setZero();
        ballBody.angularVelocity.setZero();
        
        // Only wake up standing pins to ensure they don't float
        pins.forEach(pin => {
            if (!pin.isDown) pin.body.wakeUp();
        });

        gameState = 'aiming';
        power = 0;
    }

    function resetFull() {
        resetBallOnly();
        
        // Reset all pins to original positions
        pins.forEach(pin => {
            pin.isDown = false;
            pin.body.position.copy(pin.originalPos);
            pin.body.quaternion.copy(pin.originalQuat);
            pin.body.velocity.setZero();
            pin.body.angularVelocity.setZero();
        });
    }

    // --- UI HELPERS ---
    function updateScoreboard() {
        uiS1.innerText = scores[1];
        uiS2.innerText = scores[2];
        uiTurnInfo.innerText = `Player ${playerTurn} - Frame ${frame} (Throw ${throwNum})`;
        
        // Color active player
        uiS1.parentElement.style.opacity = playerTurn === 1 ? '1' : '0.5';
        uiS2.parentElement.style.opacity = playerTurn === 2 ? '1' : '0.5';

        // Update Ball Color based on Player
        ballMesh.material.color.setHex(playerTurn === 1 ? 0xff0055 : 0x0088ff);
    }

    function showMessage(text) {
        uiMessage.innerText = text;
        uiMessage.style.opacity = 1;
        setTimeout(() => { uiMessage.style.opacity = 0; }, 1500);
    }

    // --- MAIN LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        // 1. Step Physics World
        world.step(1 / 60);

        // 2. Sync Visuals with Physics
        ballMesh.position.copy(ballBody.position);
        ballMesh.quaternion.copy(ballBody.quaternion);

        pins.forEach(pin => {
            pin.mesh.position.copy(pin.body.position);
            pin.mesh.quaternion.copy(pin.body.quaternion);
        });

        // 3. Update Power Meter if aiming
        if (gameState === 'aiming') {
            power += POWER_SPEED * powerDir;
            if (power >= 100 || power <= 0) powerDir *= -1; // Oscillate
            uiPowerBar.style.width = power + '%';
        }

        // 4. Render Scene
        renderer.render(scene, camera);
    }

    // Start everything
    init();
    updateScoreboard();

    // Handle Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
