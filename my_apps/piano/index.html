<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mobile Touch Piano</title>
  <style>
    /* Basic layout */
    :root{
      --white-key-width: calc(100vw / 7); /* default, will be overridden */
      --white-key-height: 220px;
      --black-key-height: 140px;
      --black-key-width: calc(var(--white-key-width) * 0.62);
      --active-white: #ffd; 
      --active-black: #333;
      --white-key-color: #fff;
      --black-key-color: #000;
      --border: #ccc;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(#222, #111);
      color: #eee;
      display:flex;
      flex-direction:column;
      min-height:100vh;
      align-items:center;
      padding:12px;
    }

    header{
      width:100%;
      max-width:900px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      margin-bottom:10px;
      padding:6px 4px;
    }
    .controls{
      display:flex;
      gap:8px;
      align-items:center;
    }
    label{
      font-size:13px;
      color:#ddd;
      display:flex;
      gap:6px;
      align-items:center;
    }
    select, input[type="range"]{
      height:32px;
      border-radius:6px;
      border:1px solid #444;
      background:#111;
      color:#fff;
      padding:4px 8px;
    }

    /* Keyboard container: horizontally scrollable for many keys */
    .keyboard-wrapper{
      width:100%;
      max-width:900px;
      overflow-x:auto;
      padding-bottom:10px;
      -webkit-overflow-scrolling: touch;
      border-radius:10px;
      background: linear-gradient(#0b0b0b, #111 60%);
      border: 1px solid rgba(255,255,255,0.03);
    }

    .keyboard{
      position:relative;
      height: var(--white-key-height);
      display:flex;
      user-select:none;
      touch-action: none; /* allow pointer events for multi-touch */
    }

    /* White keys layout */
    .white-key{
      position:relative;
      flex: 0 0 var(--white-key-width);
      height:100%;
      border:1px solid var(--border);
      background:var(--white-key-color);
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding-bottom:12px;
      color:#111;
      font-weight:600;
      border-radius:0 0 6px 6px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.35) inset;
      z-index:1;
    }
    .white-key.active{
      background: linear-gradient(var(--active-white), #fff);
      box-shadow: 0 1px 0 rgba(0,0,0,0.25) inset;
    }

    /* Black keys overlay (absolutely positioned) */
    .black-key{
      position:absolute;
      width: var(--black-key-width);
      height: var(--black-key-height);
      background:var(--black-key-color);
      color:#fff;
      border-radius:0 0 6px 6px;
      z-index:2;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding-bottom:8px;
      font-weight:700;
      transform: translateX(-50%);
      box-shadow: 0 6px 12px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.02);
    }
    .black-key.active{
      background: linear-gradient(#222, #111);
      box-shadow: 0 0 12px rgba(255,255,255,0.04) inset;
    }

    .note-label{
      font-size:12px;
      opacity:0.9;
      pointer-events:none;
    }

    /* Make keys taller on landscape bigger screens */
    @media (min-width:420px){
      :root{
        --white-key-height: 260px;
        --black-key-height: 170px;
      }
    }

    .hint{
      font-size:13px;
      color:#bbb;
      margin-top:8px;
      max-width:900px;
      text-align:center;
    }

    .small{
      font-size:12px;
      color:#ddd;
    }

    /* Simple responsive for many keys: recalc white key width so 14 keys fit */
    /* We'll override --white-key-width dynamically with JS to ensure exact fit for visible keys. */
  </style>
</head>
<body>
  <header>
    <div class="title">
      <strong>Touch Piano</strong>
      <div class="small">Play with multiple fingers — optimized for mobile</div>
    </div>

    <div class="controls" aria-hidden="false">
      <label>
        Waveform
        <select id="waveform" aria-label="Waveform">
          <option value="sine">Sine</option>
          <option value="square">Square</option>
          <option value="sawtooth">Saw</option>
          <option value="triangle">Triangle</option>
          <option value="mixed">Mixed</option>
        </select>
      </label>

      <label>
        Volume
        <input id="volume" type="range" min="0" max="1" step="0.01" value="0.9" aria-label="Volume"/>
      </label>

      <label>
        Sustain
        <input id="sustain" type="checkbox" aria-label="Sustain"/>
      </label>
    </div>
  </header>

  <main style="width:100%; display:flex; flex-direction:column; align-items:center;">
    <div class="keyboard-wrapper" id="keyboardWrapper">
      <div class="keyboard" id="keyboard" role="application" aria-label="Piano keyboard"></div>
    </div>

    <div class="hint">Tap keys to play. Drag across keys or use multiple fingers. Use Waveform and Volume for sound variations.</div>
  </main>

  <script>
    // Mobile Touch Piano SPA
    // Comments and UI text are in English.

    // Create an AudioContext (user gesture required on some browsers).
    let audioCtx = null;
    function ensureAudioContext(){
      if (!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    // Note utilities
    function midiToFreq(midi){
      return 440 * Math.pow(2, (midi - 69) / 12);
    }

    // Build keys: we'll create 14 white keys (2 octaves from C4 to B5)
    const startMidi = 60; // C4
    const whiteKeyCount = 14; // C4 .. A5 (14 white notes across two octaves)
    // But whiteKeyCount should be number of white keys (non-accidentals) - we will iterate by semitone and only add white keys.
    // Simpler: generate a sequence of 14 white notes by stepping notes and skipping black keys when building white keys layout.
    const whiteSequence = [];
    const blackOffsets = new Set([1,3,6,8,10]); // semitone positions that are black keys (relative to octave)
    let midi = startMidi;
    while (whiteSequence.length < whiteKeyCount){
      const pos = midi % 12;
      if (!blackOffsets.has(pos)) {
        whiteSequence.push(midi);
      }
      midi++;
    }

    // For positioning black keys, we need mapping from white key index to x position.
    // We'll create the DOM structure: many white-key elements in a row; black keys absolutely positioned over gaps.

    const keyboardEl = document.getElementById('keyboard');
    const keyboardWrapper = document.getElementById('keyboardWrapper');
    const waveformEl = document.getElementById('waveform');
    const volumeEl = document.getElementById('volume');
    const sustainEl = document.getElementById('sustain');

    function isBlackByMidi(m){
      const pos = m % 12;
      return blackOffsets.has(pos);
    }

    // Note label helper e.g., 60 -> C4
    const noteNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    function midiToName(m){
      const name = noteNames[m % 12];
      const octave = Math.floor(m / 12) - 1;
      return name + octave;
    }

    // Create white keys
    const whiteKeyEls = [];
    for (let i=0;i<whiteSequence.length;i++){
      const m = whiteSequence[i];
      const div = document.createElement('div');
      div.className = 'white-key';
      div.dataset.midi = m;
      div.dataset.note = midiToName(m);
      div.innerHTML = '<div class="note-label">' + midiToName(m) + '</div>';
      keyboardEl.appendChild(div);
      whiteKeyEls.push(div);
    }

    // Position black keys relative to white keys
    // We'll iterate semitone positions between first white midi and last white midi+12 and create black keys where appropriate.
    function addBlackKeys(){
      // Remove existing black keys if any
      const existing = keyboardEl.querySelectorAll('.black-key');
      existing.forEach(e=>e.remove());

      // For each white key, check if a black key sits between it and next white key
      for (let i=0;i<whiteKeyEls.length-1;i++){
        const leftMidi = parseInt(whiteKeyEls[i].dataset.midi,10);
        const rightMidi = parseInt(whiteKeyEls[i+1].dataset.midi,10);
        // if difference is 2 (e.g., E to F not black) then no black; if difference is 1 then there is a black between (should be 1? Actually between white keys that are separated by 2 semitones there is a black)
        const gap = rightMidi - leftMidi;
        // Normally gap will be 2 except between E-F (1) and B-C (1). For gap==2 there is a black key at leftMidi+1.
        if (gap === 2){
          const blackMidi = leftMidi + 1;
          // Create black key element
          const bk = document.createElement('div');
          bk.className = 'black-key';
          bk.dataset.midi = blackMidi;
          bk.dataset.note = midiToName(blackMidi);
          bk.innerHTML = '<div class="note-label">' + midiToName(blackMidi) + '</div>';
          // Position: compute center between left and right white key centers
          const leftRect = whiteKeyEls[i].getBoundingClientRect();
          const rightRect = whiteKeyEls[i+1].getBoundingClientRect();
          // We'll append now and set left via percent relative to keyboard width after layout recalculation
          keyboardEl.appendChild(bk);
        }
      }
      // After adding black keys, call layout function to set positions
      layoutKeys();
    }

    // Recompute white key width so exactly N white keys fit the visible keyboard wrapper width
    function layoutKeys(){
      const wrapperWidth = Math.max(keyboardWrapper.clientWidth, window.innerWidth - 24);
      // We'll set number of white keys visible to fit exactly (no gaps) — but enable horizontal scroll if keyboard wider than wrapper
      const targetWhiteWidth = Math.min(100, Math.floor(wrapperWidth / Math.min(7, whiteKeyEls.length))); // keep keys reasonable on small screens
      // We prefer to set width so that at least 7 keys visible; compute white key width based on wanting 7 visible keys OR if many keys, fit more with smaller widths
      const visibleCount = Math.min(whiteKeyEls.length, Math.max(7, Math.floor(wrapperWidth / 56)));
      const computedWidth = Math.floor(Math.max(48, wrapperWidth / visibleCount)); // minimum width 48px
      document.documentElement.style.setProperty('--white-key-width', computedWidth + 'px');
      document.documentElement.style.setProperty('--black-key-width', Math.floor(computedWidth * 0.62) + 'px');

      // Now position black keys by traversing whites and finding blacks
      const whiteRects = whiteKeyEls.map(w => w.getBoundingClientRect());
      // Convert keyboardEl bounding left to compute relative positions
      const keyboardRect = keyboardEl.getBoundingClientRect();

      // Position each black key
      const blackEls = Array.from(keyboardEl.querySelectorAll('.black-key'));
      blackEls.forEach(bk => {
        const midi = parseInt(bk.dataset.midi, 10);
        // Find the white key to the left (the white with midi less than midi)
        let leftIndex = -1;
        for (let i=whiteKeyEls.length-1;i>=0;i--){
          const wm = parseInt(whiteKeyEls[i].dataset.midi,10);
          if (wm < midi){ leftIndex = i; break; }
        }
        if (leftIndex === -1 || leftIndex >= whiteKeyEls.length-1){
          // fallback: hide if cannot position
          bk.style.display = 'none';
          return;
        }
        const leftRect = whiteKeyEls[leftIndex].getBoundingClientRect();
        const rightRect = whiteKeyEls[leftIndex+1].getBoundingClientRect();
        const leftCenter = leftRect.left + leftRect.width / 2;
        const rightCenter = rightRect.left + rightRect.width / 2;
        const center = (leftCenter + rightCenter) / 2;
        const rel = center - keyboardRect.left;
        bk.style.left = rel + 'px';
        bk.style.display = 'flex';
      });
    }

    // Initial black key creation after DOM paints
    window.addEventListener('load', ()=>{
      // Slight timeout to ensure CSS applied
      setTimeout(addBlackKeys, 20);
    });
    window.addEventListener('resize', ()=> {
      layoutKeys();
    });

    // Sound engine: create nodes per active note with simple piano-like envelope
    const activeVoices = new Map(); // midi -> voice object
    // For multi-touch tracking pointers to keys
    const pointerMap = new Map(); // pointerId -> {el, midi}

    function createVoice(midi){
      ensureAudioContext();
      const ctx = audioCtx;
      const freq = midiToFreq(midi);
      const masterGain = ctx.createGain();
      masterGain.gain.value = 0;
      const volume = parseFloat(volumeEl.value);
      masterGain.gain.value = 0; // start silent, envelope will ramp
      const finalGain = ctx.createGain();
      finalGain.gain.value = volume;
      masterGain.connect(finalGain);
      finalGain.connect(ctx.destination);

      // Make a slightly richer tone by combining oscillators when 'mixed' selected
      const nodes = [];
      const wf = waveformEl.value;
      if (wf === 'mixed'){
        // two oscillators detuned
        const o1 = ctx.createOscillator();
        o1.type = 'sawtooth';
        o1.frequency.value = freq;
        const o2 = ctx.createOscillator();
        o2.type = 'sine';
        o2.frequency.value = freq * 1.0005;
        o1.connect(masterGain);
        o2.connect(masterGain);
        o1.start();
        o2.start();
        nodes.push(o1, o2);
      } else {
        const o = ctx.createOscillator();
        o.type = wf;
        o.frequency.value = freq;
        o.connect(masterGain);
        o.start();
        nodes.push(o);
      }

      // Simple percussive envelope reminiscent of a piano (fast attack, medium decay)
      const now = ctx.currentTime;
      const attack = 0.005;
      const decay = 0.9;
      const sustainLevel = 0.0008; // effectively zero unless sustain toggled
      masterGain.gain.cancelScheduledValues(now);
      masterGain.gain.setValueAtTime(0.0001, now);
      masterGain.gain.exponentialRampToValueAtTime(1.0, now + attack);
      masterGain.gain.exponentialRampToValueAtTime(sustainLevel, now + attack + decay);

      return {
        midi,
        nodes,
        masterGain,
        finalGain,
        startTime: now,
        stop(startRelease=true){
          // If sustain is on and user didn't force stop, do not stop yet
          const sustainOn = sustainEl.checked;
          const ctx = audioCtx;
          const now = ctx.currentTime;
          const release = 0.25;
          if (sustainOn && startRelease) {
            // keep voice but mark suppressed; we'll stop when sustain toggles off
            this.isSustained = true;
            return;
          }
          // release envelope
          this.masterGain.gain.cancelScheduledValues(now);
          this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, now);
          this.masterGain.gain.exponentialRampToValueAtTime(0.0001, now + release);
          // stop oscillators after release
          setTimeout(()=> {
            try{
              this.nodes.forEach(n => n.stop && n.stop());
            }catch(e){}
            try{ this.masterGain.disconnect(); }catch(e){}
            try{ this.finalGain.disconnect(); }catch(e){}
          }, (release + 0.05) * 1000);
        }
      };
    }

    function noteOn(midi, el){
      if (activeVoices.has(midi)) return; // ignore if already playing that midi
      const v = createVoice(midi);
      activeVoices.set(midi, v);
      // Connect masterGain to audio graph
      v.masterGain.connect(audioCtx.destination); // direct to destination (finalGain already connected inside createVoice)
      if (el) el.classList.add('active');
    }

    function noteOff(midi, el){
      const v = activeVoices.get(midi);
      if (!v) return;
      v.stop(true);
      activeVoices.delete(midi);
      if (el) el.classList.remove('active');
    }

    // Also allow global stop for sustain-off
    sustainEl.addEventListener('change', ()=>{
      if (!sustainEl.checked){
        // release all voices that were sustained
        for (const [m,v] of activeVoices){
          if (v.isSustained){
            v.isSustained = false;
            v.stop(false);
            activeVoices.delete(m);
            // find key element to remove active class
            const key = keyboardEl.querySelector('[data-midi="' + m + '"]');
            if (key) key.classList.remove('active');
          }
        }
      }
    });

    // Pointer event handling for multi-touch and dragging between keys
    function handlePointerDown(e){
      // only handle primary/pointers relevant
      e.preventDefault();
      ensureAudioContext();
      // Capture pointer on the target element if it is a key
      const target = e.currentTarget;
      const midi = parseInt(target.dataset.midi,10);
      pointerMap.set(e.pointerId, {el: target, midi});
      target.setPointerCapture(e.pointerId);
      target.classList.add('pressed'); // optional quick visual
      noteOn(midi, target);
    }

    function handlePointerUp(e){
      e.preventDefault();
      const info = pointerMap.get(e.pointerId);
      if (!info) return;
      const {el, midi} = info;
      try{ el.releasePointerCapture(e.pointerId); }catch(x){}
      // releasing pointer stops the note (unless sustain)
      noteOff(midi, el);
      pointerMap.delete(e.pointerId);
      el.classList.remove('pressed');
    }

    // On pointermove we track across keys: if pointer moves to another key, switch note
    // We'll add a document-level pointermove to detect which element is under pointer
    function handlePointerCancel(e){
      // Similar to up
      const info = pointerMap.get(e.pointerId);
      if (info){
        noteOff(info.midi, info.el);
        info.el.classList.remove('pressed');
        pointerMap.delete(e.pointerId);
      }
    }

    // Helper: find highest-level key element under a client point
    function keyAtPosition(clientX, clientY){
      const el = document.elementFromPoint(clientX, clientY);
      if (!el) return null;
      // find nearest ancestor with data-midi
      return el.closest && el.closest('[data-midi]') || null;
    }

    // Attach pointer listeners to each key element
    function attachKeyListeners(){
      const keys = keyboardEl.querySelectorAll('[data-midi]');
      keys.forEach(k=>{
        k.style.touchAction = 'none';
        k.addEventListener('pointerdown', handlePointerDown);
        k.addEventListener('pointerup', handlePointerUp);
        k.addEventListener('pointercancel', handlePointerCancel);
        // Prevent default click behaviors on some browsers
        k.addEventListener('click', e => e.preventDefault());
      });
    }

    // Document-level pointermove to track drag across keys
    document.addEventListener('pointermove', (e)=>{
      // find if this pointer is being tracked
      if (!pointerMap.has(e.pointerId)) return;
      const current = pointerMap.get(e.pointerId);
      const elUnder = keyAtPosition(e.clientX, e.clientY);
      if (!elUnder) return;
      const newMidi = parseInt(elUnder.dataset.midi, 10);
      if (newMidi !== current.midi){
        // switch note
        noteOff(current.midi, current.el);
        current.el.classList.remove('pressed');
        // Update tracking to new element
        pointerMap.set(e.pointerId, {el: elUnder, midi: newMidi});
        elUnder.classList.add('pressed');
        noteOn(newMidi, elUnder);
      }
    });

    // Also handle pointerup anywhere to ensure release
    document.addEventListener('pointerup', (e)=>{
      if (pointerMap.has(e.pointerId)){
        handlePointerUp(e);
      }
    });
    document.addEventListener('pointercancel', (e)=>{
      if (pointerMap.has(e.pointerId)){
        handlePointerCancel(e);
      }
    });

    // Initialize listeners once keys are ready
    window.addEventListener('load', ()=>{
      // Re-layout and attach listeners after short delay
      setTimeout(()=>{
        layoutKeys();
        attachKeyListeners();
      }, 50);
    });

    // If user interacts with controls, ensure AudioContext created on gesture
    [waveformEl, volumeEl, sustainEl].forEach(ctrl=>{
      ctrl.addEventListener('pointerdown', () => ensureAudioContext());
    });

    // Visual update: toggle active class when voice starts/stops using mutation or event - we already set in noteOn/noteOff

    // Optional: quick keyboard support for desktops (A..K mapping)
    window.addEventListener('keydown', (e)=>{
      if (e.repeat) return;
      const map = {
        'a':0,'w':1,'s':2,'e':3,'d':4,'f':5,'t':6,'g':7,'y':8,'h':9,'u':10,'j':11,'k':12
      };
      const key = e.key.toLowerCase();
      if (key in map){
        const idx = map[key];
        if (idx < whiteKeyEls.length){
          const midi = parseInt(whiteKeyEls[idx].dataset.midi,10);
          noteOn(midi, whiteKeyEls[idx]);
        }
      }
    });
    window.addEventListener('keyup', (e)=>{
      const map = {
        'a':0,'w':1,'s':2,'e':3,'d':4,'f':5,'t':6,'g':7,'y':8,'h':9,'u':10,'j':11,'k':12
      };
      const key = e.key.toLowerCase();
      if (key in map){
        const idx = map[key];
        if (idx < whiteKeyEls.length){
          const midi = parseInt(whiteKeyEls[idx].dataset.midi,10);
          noteOff(midi, whiteKeyEls[idx]);
        }
      }
    });

    // Keep layout reactive to changes (e.g., orientation)
    new ResizeObserver(()=> layoutKeys()).observe(keyboardWrapper);

  </script>
</body>
</html>