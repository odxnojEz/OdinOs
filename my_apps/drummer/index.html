<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Pro Mobile Drum Kit</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #606060;
            /* Critical for multitouch: prevents zooming, scrolling and pull-to-refresh */
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            display: block;
        }

        #start-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at center, #2a2a2a 0%, #000000 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        button {
            padding: 20px 50px;
            font-size: 24px;
            font-weight: 900;
            color: #fff;
            background: linear-gradient(135deg, #ff3b30, #ff9500);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(255, 59, 48, 0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            transform: scale(0.92);
            box-shadow: 0 5px 15px rgba(255, 59, 48, 0.4);
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <button id="start-btn">Play Drums</button>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // 1. ADVANCED PROCEDURAL AUDIO ENGINE
        // ==========================================
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        const drumBuffers = {};

        // Procedural drum synthesizer for realistic fallbacks
        function generateDrumSound(type) {
            if (!audioCtx) return null;
            const sampleRate = audioCtx.sampleRate;
            let duration = 1.0;
            
            if (type === 'kick') duration = 0.5;
            if (type === 'snare') duration = 0.4;
            if (type === 'hihat') duration = 0.15;
            if (type.includes('tom')) duration = 0.8;
            if (type.includes('crash') || type === 'ride') duration = 2.5;

            const buffer = audioCtx.createBuffer(1, sampleRate * duration, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < buffer.length; i++) {
                const t = i / sampleRate;
                let sample = 0;

                if (type === 'kick') {
                    // Pitch drop + fast decay
                    const freq = 150 * Math.exp(-t * 20) + 40;
                    sample = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 10);
                    // Add click
                    if (t < 0.01) sample += (Math.random() - 0.5) * 0.5; 
                } 
                else if (type === 'snare') {
                    // Tonal body + white noise tail
                    const freq = 200 * Math.exp(-t * 10) + 150;
                    const tone = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 15);
                    const noise = (Math.random() * 2 - 1) * Math.exp(-t * 12);
                    sample = tone * 0.5 + noise * 0.8;
                }
                else if (type.includes('tom')) {
                    // Similar to kick but higher and longer resonant decay
                    const baseFreq = type === 'tom1' ? 180 : (type === 'tom2' ? 130 : 90);
                    const freq = baseFreq * Math.exp(-t * 8) + (baseFreq * 0.7);
                    sample = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 5);
                }
                else if (type === 'hihat') {
                    // Filtered high-frequency noise
                    sample = (Math.random() * 2 - 1) * Math.exp(-t * 35);
                }
                else if (type.includes('crash') || type === 'ride') {
                    // Complex metallic sound (layered noise with slow decay)
                    const decay = type === 'ride' ? 1.5 : 2.5;
                    sample = (Math.random() * 2 - 1) * Math.exp(-t * decay);
                    // Add some ping for the ride
                    if (type === 'ride') {
                        sample += Math.sin(2 * Math.PI * 400 * t) * Math.exp(-t * 3) * 0.2;
                    }
                }
                data[i] = sample;
            }
            return buffer;
        }

        async function initAudio() {
            const types = ['kick', 'snare', 'hihat', 'tom1', 'tom2', 'floortom', 'crash1', 'crash2', 'ride'];
            types.forEach(type => {
                drumBuffers[type] = generateDrumSound(type);
                // Note: You can replace the line above with your fetch logic later:
                // loadSample(type, `samples/${type}.wav`);
            });
        }

        // ==========================================
        // 2. THREE.JS SCENE & DRUMMER PERSPECTIVE
        // ==========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a0a, 5, 20);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Responsive Camera Logic
        function updateCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            
            if (aspect < 1) { 
                // Portrait Mode: Move higher, wider FOV to fit the whole kit
                camera.position.set(0, 8.5, 3.5);
                camera.fov = 75;
            } else { 
                // Landscape Mode: Closer, drummer's natural eye level
                camera.position.set(0, 6, 2.5);
                camera.fov = 65;
            }
            
            camera.lookAt(0, 1, -1);
            camera.updateProjectionMatrix();
        }
        
        window.addEventListener('resize', () => {
            updateCamera();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        updateCamera(); // Initial setup

        // Lighting
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x222222, 0.5);
        scene.add(ambientLight);
        
        const spotLight = new THREE.SpotLight(0xffffff, 200);
        spotLight.position.set(0, 10, 0);
        spotLight.angle = Math.PI / 4;
        spotLight.penumbra = 0.5;
        scene.add(spotLight);

        // ==========================================
        // 3. DRUM KIT MODELING (EXTENDED)
        // ==========================================
        const drumGroup = new THREE.Group();
        scene.add(drumGroup);

        const materials = {
            shell: new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.6, roughness: 0.4 }),
            head: new THREE.MeshStandardMaterial({ color: 0xf0f0f0, metalness: 0.1, roughness: 0.9 }),
            cymbal: new THREE.MeshStandardMaterial({ color: 0xe5b80b, metalness: 1.0, roughness: 0.2 }),
            hardware: new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.1 })
        };

        function createDrum(id, radius, height, position, rotation = [0,0,0]) {
            const group = new THREE.Group();
            
            const shell = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, height, 32, 1, true), materials.shell);
            const topHead = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, 0.02, 32), materials.head);
            topHead.position.y = height / 2;
            
            group.add(shell);
            group.add(topHead);
            
            group.position.set(...position);
            group.rotation.set(...rotation);
            
            topHead.userData = { isInteractable: true, drumId: id, isKick: id === 'kick' };
            group.userData.hitTarget = topHead;

            drumGroup.add(group);
            return group;
        }

        function createCymbal(id, radius, position, rotation = [0,0,0]) {
            const group = new THREE.Group();
            
            // Cymbal disc
            const mesh = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, 0.01, 32), materials.cymbal);
            // Center bell
            const bell = new THREE.Mesh(new THREE.SphereGeometry(radius * 0.2, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.5), materials.cymbal);
            bell.position.y = 0.01;

            group.add(mesh);
            group.add(bell);
            
            group.position.set(...position);
            group.rotation.set(...rotation);
            
            mesh.userData = { isInteractable: true, drumId: id, isKick: false };
            bell.userData = { isInteractable: true, drumId: id, isKick: false };

            drumGroup.add(group);
            return group;
        }

        // --- Build Full Kit (Positions relative to Snare roughly at 0, 1.5, 0) ---
        // (ID, Radius, Height/Pos, X, Y, Z, RotX, RotY, RotZ)
        
        // Kick (Bombo) - Placed deeper in Z
        createDrum('kick', 1.2, 1.8, [0, 0.6, -2.5], [Math.PI / 2, 0, 0]);
        
        // Snare (Caja) - Center focus
        createDrum('snare', 0.7, 0.35, [-0.5, 1.8, -0.2], [0.1, 0, 0.1]);
        
        // Toms
        createDrum('tom1', 0.55, 0.5, [-0.9, 2.5, -1.8], [0.3, 0, -0.1]);
        createDrum('tom2', 0.6, 0.5, [0.7, 2.5, -1.9], [0.3, 0, 0.1]);
        createDrum('floortom', 0.8, 0.9, [1.6, 1.4, -0.2], [0.05, 0, 0.05]);

        // Cymbals
        createCymbal('hihat', 0.7, [-1.8, 2.2, -0.2], [0.05, 0, 0.1]);
        createCymbal('crash1', 0.9, [-1.9, 3.2, -1.8], [0.2, 0, 0.2]);
        createCymbal('crash2', 0.95, [1.8, 3.3, -2.0], [0.2, 0, -0.2]);
        createCymbal('ride', 1.1, [2.1, 2.7, -1.0], [0.15, 0, -0.1]);


        // ==========================================
        // 4. MULTITOUCH & RAYCASTING
        // ==========================================
        const raycaster = new THREE.Raycaster();

        // Handle native pointer events for true multitouch
        function handleInteraction(event) {
            // Normalize pointer coordinates
            const pointer = new THREE.Vector2();
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            
            // Intersect recursive to catch nested meshes (like cymbal bell)
            const intersects = raycaster.intersectObjects(drumGroup.children, true);
            
            for (let i = 0; i < intersects.length; i++) {
                const object = intersects[i].object;
                
                if (object.userData.isInteractable) {
                    playDrumNode(object);
                    break; // Only trigger the first hit surface
                }
            }
        }

        window.addEventListener('pointerdown', handleInteraction);

        function playDrumNode(mesh) {
            const id = mesh.userData.drumId;

            // 1. Zero-latency Audio Trigger
            if (audioCtx && drumBuffers[id]) {
                const source = audioCtx.createBufferSource();
                source.buffer = drumBuffers[id];
                
                // Slight volume adjustment based on type
                const gainNode = audioCtx.createGain();
                gainNode.gain.value = id === 'kick' ? 1.2 : 0.8;
                
                source.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                source.start(0);
            }

            // 2. Visual Haptic Feedback (GSAP scaling)
            // We animate the parent group so the whole drum/cymbal scales, not just the head
            const target = mesh.parent; 
            gsap.killTweensOf(target.scale);
            target.scale.set(1, 1, 1);
            
            // Different animation for cymbals vs drums
            const isCymbal = id.includes('crash') || id.includes('hihat') || id.includes('ride');
            const scaleDown = isCymbal ? 0.95 : 0.9;
            
            gsap.to(target.scale, {
                x: 1.02, y: scaleDown, z: 1.02, 
                duration: 0.06, 
                yoyo: true, 
                repeat: 1,
                ease: "power1.out"
            });

            // 3. Physical Haptic Vibration
            if (navigator.vibrate) {
                if (mesh.userData.isKick) {
                    navigator.vibrate(30); // Stronger for kick
                } else {
                    navigator.vibrate(10); // Light tap for others
                }
            }
        }

        // ==========================================
        // 5. LIFECYCLE & RENDER LOOP
        // ==========================================
        document.getElementById('start-btn').addEventListener('click', async () => {
            audioCtx = new AudioContext();
            await initAudio(); // Generate the procedural sounds
            
            audioCtx.resume().then(() => {
                const overlay = document.getElementById('start-overlay');
                gsap.to(overlay, { 
                    opacity: 0, 
                    duration: 0.5, 
                    onComplete: () => overlay.style.display = 'none' 
                });
            });
        });

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

    </script>
</body>
</html>
